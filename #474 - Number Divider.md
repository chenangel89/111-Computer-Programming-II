```c
#include<stdio.h>
#define N 201

int main()
{
    int m, n;
    int dp[N][N] = {0};
    scanf("%d%d", &m, &n);
    dp[0][0] = 1;
    for(int i = 0; i <= m; i++) {
        for(int j = 1; j <= n; j++) {
            dp[i][j] = dp[i][j - 1];
            if (i >= j) dp[i][j] += dp[i - j][j];
        }
    }
    printf("%d\n", dp[m][n]);
    return 0;
}
```

狀態轉移方程
通過這個劃分,可以將左右的組合劃分成兩部分,一部分為 在這個組合中最小值為0, 另一部分則是最小值不是0

由於刪去0以後對這部分的組合數量不影響,所以可以將0刪去, 所以劃分了j - 1個,由於刪去0以後對剩餘的數的總和不影響, 所以此時的dp表示為 dp[i][j - 1]

對於不是0的部分, 將組合中的數全部同時減1以後, 該組合的數量和沒有減1以後的組合的數量相同, 所以可以減1. 此時, 所有的數的總和為 i - j, 由於只是減1, 所以劃分的數量不變, 為j, 此時的dp表示為 dp[i - j][j]

所以狀態轉移方程則是
dp[i][j] = dp[i][j - 1] + dp[i - j][j]

初始化
當拆分0的時候,總共能拆分0次,那麼就有一種拆分方法,則是什麼都不拆
dp[0][0] = 1
————————————————
版權聲明：本文為CSDN博主「ghost_him」的原創文章，遵循CC 4.0 BY-SA版權協議，轉載請附上原文出處鏈接及本聲明。
[原文鏈接](https://blog.csdn.net/ghost_him/article/details/123055311)
